#include "dynamixel_sdk/dynamixel_sdk.h"
#include "std_msgs/Float64MultiArray.h"
#include "sensor_msgs/JointState.h"
#include "ros/ros.h"

/*
 * THIS PROGRAM OPERATES JUSTINA'S LEFT ARM CONSIDERING ONLY 6 MOTORS, SINCE THE 7TH DOF
 * IS A MX28 MOTOR WHICH DOES NOT ALLOW TORQUE CONTROL. NEVERTHELESS, THIS PROGRAM PUBLISHES
 * 7 JOINT STATES, CONSIDERING THE 7TH GOAL POSE, CURRENT POSE AND TORQUE BEING ALWAYS ZERO.
 */

int    center_bits[6]  = {1543, 1600, 1800, 2100, 2048, 1800};
float  bits_per_radian = 4096.0/M_PI/2.0;
float  bits_per_N_m[6] = {1023/7.3656, 1023/7.3656, 1023/6.4626, 1023/7.3656, 1023/6.4626, 1023/6.4626};
int    directions[6]   = {-1, -1, -1,  1, -1, -1};

std::string joint_names[7] = {"la_1_joint","la_2_joint","la_3_joint","la_4_joint","la_5_joint", "la_6_joint", "la_7_joint"};

std::vector<uint16_t> goal_torque;
void callback_la_torque(const std_msgs::Float64MultiArray::ConstPtr& msg)
{
    //According to the specs https://emanual.robotis.com/docs/en/dxl/mx/mx-106/
    //MX106 motors generate an approx of 1.6 N-m of torque per ampere of current
    //and, when controlling torque, every bit in (0-1023) is equal to 4.5 mA,
    //i.e., 1023= 4603.5 mA which will generate an approx of 7.3656 N-m of torque.
    //For MX64 motors, torque/current relation is about 1.45 thus
    //1023 = 4603.5 mA = 6.4626 N-m. Consider that this value may exceed the
    //maximum torque that can be generated by MX64
    //This constant is reflected in the bits_per_N_m variables.
    std::cout << "Received new goal torque:" << std::endl;
    for(size_t i=0; i< goal_torque.size(); i++)
    {
        goal_torque[i] = (uint16_t)(fabs(msg->data[i])*bits_per_N_m[i]);
        if(directions[i]*msg->data[i] < 0)
            goal_torque[i] = goal_torque[i] | 0x0400; //Bit 10 sets torque direction
        std::cout << (int)goal_torque[i] << "   ";
    }
    std::cout << std::endl;
}

int main(int argc, char **argv)
{
    /*
     * Initializing ROS stuff: node, publishers and subscribers.
     */
    std::cout << "INITIALIZING LEFT_ARM_NODE ..." << std::endl;
    ros::init(argc, argv, "bulk_read_2_bytes");
    ros::NodeHandle n("~");
    ros::Publisher  pub_current_pose = n.advertise<std_msgs::Float64MultiArray>("/hardware/la_current_pose", 1);
    ros::Publisher  pub_joint_states = n.advertise<sensor_msgs::JointState>("/joint_states", 1);
    ros::Subscriber sub_goal_pose    = n.subscribe("/hardware/la_torque", 1, callback_la_torque);
    ros::Rate loop(250);


    /*
     * Reading and parsing parameters.
     */
    int baudrate = 1000000;
    std::string port    = "/dev/ttyUSB0";
    std::string str_ids = "1 2 3 4 5 6";
    if(ros::param::has("~port"))
        ros::param::get("~port", port);
    if(ros::param::has("~baudrate"))
        ros::param::get("~baudrate", baudrate);
    if(ros::param::has("~servo_ids"))
        ros::param::get("~servo_ids", str_ids);
    std::vector<int>      servo_IDs;
    std::istringstream iss(str_ids);
    for(std::string s; iss >> s;)
        servo_IDs.push_back(atoi(s.c_str()));

    std::cout << "LeftArm.->Using IDs: ";
    for(int i=0; i < servo_IDs.size(); i++) std::cout << servo_IDs[i] << "  ";
    std::cout << std::endl;
    std::cout << "LeftArm.->Using port: " << port << "  at " << baudrate << std::endl;

    
    /*
     * Initializing variables for reading and writing through serial port
     */
    std::string latencia = "echo 1 | sudo tee /sys/bus/usb-serial/devices/ttyUSB0/latency_timer";
    char const *late = latencia.data();
    system(late);     
    
    dynamixel::PortHandler   *portHandler   = dynamixel::PortHandler::getPortHandler(port.c_str());
    dynamixel::PacketHandler *packetHandler = dynamixel::PacketHandler::getPacketHandler(1.0);
    dynamixel::GroupBulkRead  groupBulkRead(portHandler, packetHandler);
    dynamixel::GroupSyncWrite groupSyncWriteTorque      (portHandler, packetHandler, 71, 2);
    dynamixel::GroupSyncWrite groupSyncWriteTorqueEnable(portHandler, packetHandler, 70, 1);
    portHandler->setBaudRate(baudrate);
    int dxl_comm_result = COMM_TX_FAIL; 
    uint8_t goal_torque_bits[2] = {0, 0};
    uint8_t control_torque_en = 1;
    uint8_t dxl_error = 0;             
    for(size_t i=0; i < servo_IDs.size(); i++)
        if(!groupBulkRead.addParam(servo_IDs[i], 36, 2) ||
           !groupSyncWriteTorqueEnable.addParam(servo_IDs[i], &control_torque_en) ||
           !groupSyncWriteTorque.addParam(servo_IDs[i], goal_torque_bits))
        {
            std::cout << "Cannot add parameter to bulk readers/writers for servo " << servo_IDs[i] << std::endl;
            return -1;
        }
    dxl_comm_result = groupSyncWriteTorqueEnable.txPacket();
    if (dxl_comm_result != COMM_SUCCESS)
    {
        std::cout << "ERROR COMMUNICATION while trying to enable torque control: " << int(dxl_comm_result) << std::endl;
        return -1;
    }

    /*
     * Variables for getting positions and publishing their values and setting goal torques
     */
    std_msgs::Float64MultiArray msg_current_pose;
    sensor_msgs::JointState joint_states;
    for(int i=0; i <servo_IDs.size(); i++)
        goal_torque.push_back(0);
    joint_states.position.resize(7);
    joint_states.name.insert(joint_states.name.begin(), joint_names, joint_names + 7);
    msg_current_pose.data.resize(7);
    msg_current_pose.data[6] = 0;
    int rate_downsampling = 0;
    
    while(ros::ok())
    {
        
        dxl_comm_result = groupBulkRead.txRxPacket();
        if (dxl_comm_result != COMM_SUCCESS)
        {
            std::cout << "ERROR COMMUNICATION: " << int(dxl_comm_result) << std::endl;
            continue;
        }
        
        for(size_t i=0; i< servo_IDs.size(); i++)
            if(!groupBulkRead.isAvailable(servo_IDs[i], 36, 2))
                std::cout << "[ID:" << servo_IDs[i] << " groupBulkRead getdata failed" << std::endl;
            else
                msg_current_pose.data[i] = directions[i]*(center_bits[i]-(int)(groupBulkRead.getData(servo_IDs[i], 36, 2)))/bits_per_radian;
        
        pub_current_pose.publish(msg_current_pose);
        
        if(++rate_downsampling > 20)
        {
            rate_downsampling = 0;
            joint_states.position = msg_current_pose.data;
            joint_states.header.stamp = ros::Time::now();
            pub_joint_states.publish(joint_states);
        }
        
        for(size_t i=0; i < servo_IDs.size(); i++)
        {
            goal_torque_bits[0] = DXL_LOBYTE(goal_torque[i]);
            goal_torque_bits[1] = DXL_HIBYTE(goal_torque[i]);
            if(!groupSyncWriteTorque.changeParam(servo_IDs[i], goal_torque_bits))
                std::cout << "Cannot change parameter to goal torque sync writer for servo " << servo_IDs[i] << std::endl;
        }
        dxl_comm_result = groupSyncWriteTorque.txPacket();
        if (dxl_comm_result != COMM_SUCCESS) std::cout << "ERROR COMMUNICATION: " << int(dxl_comm_result) << std::endl;

        ros::spinOnce();
        loop.sleep();
    }
}

